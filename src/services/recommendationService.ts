import { supabase } from "@/integrations/supabase/client";

export interface Course {
  id: string;
  title: string;
  description: string;
  difficulty: string;
  tags: string[];
  rating: number;
}

export interface TagStats {
  tag: string;
  count: number;
}

export interface AIRecommendation {
  type: "problem" | "course" | "tip";
  title: string;
  description: string;
  difficulty?: string;
  link?: string;
}

// This would ideally come from a real API with ML model
// For now we're using dummy data that would be generated by an AI
export const getRecommendedCourses = async (userId: string): Promise<Course[]> => {
  // In a real app, this would be fetched from a database or ML service
  // based on user's learning patterns and problems solved
  return [
    {
      id: "1",
      title: "Dynamic Programming Masterclass",
      description: "Learn advanced techniques for solving DP problems efficiently",
      difficulty: "Advanced",
      tags: ["Dynamic Programming", "Algorithms"],
      rating: 4.8
    },
    {
      id: "2",
      title: "Graph Theory Fundamentals",
      description: "Essential concepts in graph theory with practical applications",
      difficulty: "Intermediate",
      tags: ["Graphs", "BFS", "DFS"],
      rating: 4.6
    },
    {
      id: "3",
      title: "Data Structures Deep Dive",
      description: "In-depth exploration of advanced data structures",
      difficulty: "Intermediate",
      tags: ["Data Structures", "Trees", "Heaps"],
      rating: 4.7
    }
  ];
};

export const getUserTagStats = async (userId: string): Promise<TagStats[]> => {
  try {
    // Get the user's solved problems
    const { data: submissions, error: subError } = await supabase
      .from('submissions')
      .select('problem_id')
      .eq('user_id', userId)
      .eq('status', 'accepted');

    if (subError) throw subError;
    if (!submissions.length) return [];

    // Get problem tags for solved problems
    const problemIds = submissions.map(sub => sub.problem_id);
    const { data: problems, error: probError } = await supabase
      .from('problems')
      .select('tags')
      .in('id', problemIds);

    if (probError) throw probError;

    // Count tags
    const tagCounts: Record<string, number> = {};
    problems.forEach(problem => {
      if (problem.tags) {
        problem.tags.forEach((tag: string) => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      }
    });

    // Convert to array format
    return Object.entries(tagCounts).map(([tag, count]) => ({ tag, count }));
  } catch (error) {
    console.error('Error getting user tag stats:', error);
    return [];
  }
};

export const getAIRecommendations = async (userId: string): Promise<AIRecommendation[]> => {
  // In a real app, this would call an AI service to generate personalized recommendations
  // based on the user's performance, learning style, and goals
  
  return [
    {
      type: "problem",
      title: "Two Sum with Constraints",
      description: "Try this problem to improve your array manipulation and optimization skills",
      difficulty: "Medium",
      link: "/problems/42"
    },
    {
      type: "tip",
      title: "Improve your Dynamic Programming",
      description: "You seem to struggle with DP problems. Try breaking them down into smaller subproblems and build a solution iteratively."
    },
    {
      type: "course",
      title: "Graph Algorithms for Competitive Programming",
      description: "This course will help you master graph theory concepts that often appear in contests",
      link: "/courses/graph-algorithms"
    }
  ];
};
